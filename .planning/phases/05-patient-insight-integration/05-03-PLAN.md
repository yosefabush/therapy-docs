---
phase: 05-patient-insight-integration
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/app/api/patients/[id]/insights/route.ts
  - src/lib/data/repositories.ts
  - src/components/patients/InsightPanel.tsx
  - src/app/patients/[id]/page.tsx
  - src/app/insights/page.tsx
autonomous: true

# Note: This plan has 4 tasks which is borderline scope.
# Tasks are kept together because they form a cohesive persistence layer:
# repository -> API endpoints -> UI save -> UI load
# Splitting would create unnecessary context switching between related concerns.

must_haves:
  truths:
    - "Insights persist across page reloads"
    - "Saved insights display immediately on patient profile"
    - "Therapist can regenerate to get updated analysis"
    - "GET endpoint returns saved insights"
    - "PATCH endpoint saves generated insights"
    - "Insights page shows saved insights (from patient profile) when patient selected"
  artifacts:
    - path: "src/app/api/patients/[id]/insights/route.ts"
      provides: "GET and PATCH endpoints for insight persistence"
      exports: ["GET", "POST", "PATCH"]
    - path: "src/lib/data/repositories.ts"
      provides: "patientInsightsRepository with CRUD operations"
      contains: "patientInsightsRepository"
  key_links:
    - from: "src/components/patients/InsightPanel.tsx"
      to: "/api/patients/[id]/insights"
      via: "PATCH request in handleSave"
      pattern: "method.*PATCH"
    - from: "src/app/patients/[id]/page.tsx"
      to: "/api/patients/[id]/insights GET"
      via: "fetch existing insights on mount"
      pattern: "fetch.*api/patients.*insights"
    - from: "src/app/insights/page.tsx"
      to: "/api/patients/[id]/insights GET"
      via: "fetch saved insights first, fallback to POST"
      pattern: "fetch.*api/patients.*insights"
---

<objective>
Add persistence layer for patient insights with GET/PATCH endpoints and saved state handling

Purpose: Enable insights to persist and be regenerated (INSI-08), and connect patient profile generation to insights page viewing (INSI-01 completion)
Output: Complete persistence flow with repository, API endpoints, and UI integration across both pages
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-patient-insight-integration/05-01-SUMMARY.md
@.planning/phases/05-patient-insight-integration/05-02-SUMMARY.md
@src/app/api/patients/[id]/insights/route.ts
@src/lib/data/repositories.ts
@src/components/patients/InsightPanel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add insights repository</name>
  <files>src/lib/data/repositories.ts</files>
  <action>
Add patientInsightsRepository to the existing repositories file.

**Storage Pattern:**
Follow the same pattern as other repositories in the file (likely using JSON storage or mock data).

**Repository Interface:**
```typescript
export const patientInsightsRepository = {
  /**
   * Find insights by patient ID
   * Returns null if no saved insights exist
   */
  async findByPatientId(patientId: string): Promise<PatientInsights | null> {
    // Check if insights exist in storage for this patient
    // Return null if not found
  },

  /**
   * Save or update insights for a patient
   * If insights exist, update them; otherwise create new
   */
  async save(insights: PatientInsights): Promise<PatientInsights> {
    // Add savedAt and savedBy if not present
    // Store in data (following existing repository patterns)
    // Return the saved insights
  },

  /**
   * Delete insights for a patient (for regeneration)
   */
  async deleteByPatientId(patientId: string): Promise<void> {
    // Remove insights from storage
  },
};
```

**Import PatientInsights:**
Add to imports: `import type { PatientInsights } from '@/types';`

**Storage Location:**
If using JSON files, store in `data/insights/` directory.
If using in-memory mock, add to mock data structure.
Follow existing patterns in the file.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- patientInsightsRepository exported from repositories.ts
- findByPatientId, save, deleteByPatientId methods exist
  </verify>
  <done>
patientInsightsRepository exists with CRUD operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Add GET and PATCH endpoints</name>
  <files>src/app/api/patients/[id]/insights/route.ts</files>
  <action>
Add GET and PATCH handlers to the existing route file:

**GET /api/patients/[id]/insights**
Retrieves saved insights for a patient:
```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;

    // Validate patient exists
    const patient = await patientRepository.findById(id);
    if (!patient) {
      return NextResponse.json(
        { error: 'Patient not found' },
        { status: 404 }
      );
    }

    // Get saved insights
    const insights = await patientInsightsRepository.findByPatientId(id);

    // Return insights or null
    return NextResponse.json({ data: insights });
  } catch (error) {
    console.error('Error fetching patient insights:', error);
    return NextResponse.json(
      { error: 'Failed to fetch insights' },
      { status: 500 }
    );
  }
}
```

**PATCH /api/patients/[id]/insights**
Saves generated insights:
```typescript
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const body = await request.json();

    // Validate patient exists
    const patient = await patientRepository.findById(id);
    if (!patient) {
      return NextResponse.json(
        { error: 'Patient not found' },
        { status: 404 }
      );
    }

    // Validate required fields
    if (!body.insights) {
      return NextResponse.json(
        { error: 'Missing insights in request body' },
        { status: 400 }
      );
    }

    // Add persistence metadata
    const insightsToSave: PatientInsights = {
      ...body.insights,
      savedAt: new Date(),
      // savedBy would come from auth in real app
    };

    // Save insights
    const savedInsights = await patientInsightsRepository.save(insightsToSave);

    return NextResponse.json({ data: savedInsights });
  } catch (error) {
    console.error('Error saving patient insights:', error);
    return NextResponse.json(
      { error: 'Failed to save insights' },
      { status: 500 }
    );
  }
}
```

**Import:**
Add `patientInsightsRepository` to imports from '@/lib/data/repositories'
  </action>
  <verify>
- `npx tsc --noEmit` passes
- GET endpoint returns saved insights or null
- PATCH endpoint saves insights with savedAt timestamp
  </verify>
  <done>
GET and PATCH endpoints exist for insight persistence
  </done>
</task>

<task type="auto">
  <name>Task 3: Update InsightPanel for persistence and patient page integration</name>
  <files>src/components/patients/InsightPanel.tsx, src/app/patients/[id]/page.tsx</files>
  <action>
**Part A: Update InsightPanel to handle saved insights and persistence**

**1. Add handleSave function:**
```typescript
const handleSave = async () => {
  if (!insights) return;

  setSaveError(null);
  try {
    const response = await fetch(`/api/patients/${patientId}/insights`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ insights }),
    });

    const result = await response.json();

    if (!response.ok || result.error) {
      setSaveError(result.error || 'Failed to save insights');
      return;
    }

    // Update local state with saved version
    setInsights(result.data);
    setState('saved');
    onInsightsSaved?.();
  } catch {
    setSaveError('Failed to connect to server');
  }
};
```

**2. Handle existingInsights prop:**
```typescript
useEffect(() => {
  if (existingInsights) {
    setState(existingInsights.savedAt ? 'saved' : 'preview');
    setInsights(existingInsights);
  }
}, [existingInsights]);
```

**3. Update state type:**
Add `saveError` state for save-specific errors:
```typescript
const [saveError, setSaveError] = useState<string | null>(null);
```

**4. Saved state display:**
In saved state, show:
- "Saved" badge (green)
- savedAt timestamp formatted
- Regenerate button only (no Save button)
- Clear indication that insights are persisted

**5. Preview state display:**
- "Unsaved" badge (outline)
- Save button (primary)
- Regenerate button (secondary)
- saveError message if present

---

**Part B: Update patient page to load existing insights**

**1. Add state and fetch:**
```typescript
const [existingInsights, setExistingInsights] = useState<PatientInsights | null>(null);
const [insightsLoading, setInsightsLoading] = useState(false);

// Fetch existing insights on mount
useEffect(() => {
  const fetchInsights = async () => {
    if (!patient?.id) return;
    setInsightsLoading(true);
    try {
      const response = await fetch(`/api/patients/${patient.id}/insights`);
      const result = await response.json();
      if (result.data) {
        setExistingInsights(result.data);
      }
    } catch (error) {
      console.error('Failed to fetch insights:', error);
    } finally {
      setInsightsLoading(false);
    }
  };

  if (patient?.id && completedSessions.length > 0) {
    fetchInsights();
  }
}, [patient?.id, completedSessions.length]);
```

**2. Update InsightPanel props:**
```tsx
<InsightPanel
  patientId={patient.id}
  patientName={`${patient.firstName} ${patient.lastName}`}
  existingInsights={existingInsights}
  onInsightsSaved={() => {
    // Optionally refetch to get latest saved state
    // Or trust the InsightPanel's local state
  }}
/>
```

**3. Add import:**
```typescript
import type { PatientInsights } from '@/types';
```

**4. Handle loading:**
Show loading state in InsightPanel area while fetching, or let InsightPanel show empty and transition when insights arrive.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- handleSave calls PATCH endpoint
- Saved state shows savedAt timestamp
- Save button works from preview state
- Patient page loads existing insights on mount via GET
  </verify>
  <done>
InsightPanel persists insights via PATCH and patient page loads saved insights via GET
  </done>
</task>

<task type="auto">
  <name>Task 4: Update insights page to show saved insights</name>
  <files>src/app/insights/page.tsx</files>
  <action>
Update insights page to first check for saved insights (GET) before generating new ones (POST).

This completes INSI-01: insights generated on patient profile can be viewed on the insights page.

**Update fetchInsights function:**
```typescript
const fetchInsights = async (patientId: string) => {
  setInsightsLoading(true);
  setInsightsError(null);

  try {
    // First, try to get saved insights
    const getResponse = await fetch(`/api/patients/${patientId}/insights`);
    const getResult = await getResponse.json();

    if (getResponse.ok && getResult.data) {
      // Found saved insights - display them
      setInsights(getResult.data);
      setInsightsLoading(false);
      return;
    }

    // No saved insights - generate new ones via POST
    const postResponse = await fetch(`/api/patients/${patientId}/insights`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
    });

    const postResult = await postResponse.json();

    if (!postResponse.ok || postResult.error) {
      setInsightsError(postResult.error || `Server error (${postResponse.status})`);
      setInsights(null);
      return;
    }

    if (postResult.data) {
      setInsights(postResult.data);
    } else {
      setInsightsError('Invalid response format');
      setInsights(null);
    }
  } catch (err) {
    console.error('Failed to fetch insights:', err);
    setInsightsError('Network error - could not connect to server');
    setInsights(null);
  } finally {
    setInsightsLoading(false);
  }
};
```

**Add "saved" indicator:**
When displaying saved insights (those with savedAt), show a badge indicating they were saved from patient profile:
```tsx
{insights.savedAt && (
  <Badge variant="success">
    Saved {formatRelativeTime(insights.savedAt)}
  </Badge>
)}
```

**Regenerate behavior:**
The existing "Regenerate" button should skip the GET check and go directly to POST to generate fresh insights.

```typescript
const handleRegenerate = async () => {
  if (!selectedPatientId) return;

  setInsightsLoading(true);
  setInsightsError(null);

  try {
    // Force regeneration via POST (skip GET check)
    const response = await fetch(`/api/patients/${selectedPatientId}/insights`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
    });

    const result = await response.json();

    if (!response.ok || result.error) {
      setInsightsError(result.error || 'Failed to regenerate');
      return;
    }

    if (result.data) {
      setInsights(result.data);
    }
  } catch (err) {
    console.error('Regeneration failed:', err);
    setInsightsError('Network error');
  } finally {
    setInsightsLoading(false);
  }
};
```

This enables the full INSI-01 flow:
1. Therapist generates insights on patient profile page
2. Therapist saves insights
3. Therapist navigates to AI insights page
4. Selects same patient
5. Sees saved insights immediately (no regeneration needed)
6. Can regenerate if desired
  </action>
  <verify>
- `npm run build` passes
- Insights page tries GET first, falls back to POST
- Saved insights display with "saved" indicator
- Regenerate button forces new generation
  </verify>
  <done>
Insights page shows saved insights from patient profile, completing INSI-01 navigation flow
  </done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run build` succeeds
- [ ] GET /api/patients/[id]/insights returns saved insights
- [ ] PATCH /api/patients/[id]/insights saves insights
- [ ] InsightPanel Save button persists to API
- [ ] Patient page loads existing insights on mount
- [ ] Saved insights show "Saved" badge and savedAt timestamp
- [ ] Regenerate creates new insights (replaces old)
- [ ] Insights persist across page reloads
- [ ] Insights page shows saved insights when patient selected
- [ ] Full INSI-01 flow works: generate on profile -> save -> view on insights page
</verification>

<success_criteria>
Insights are saved and persist across sessions; therapist can regenerate to get updated analysis (INSI-08 satisfied). Insights generated on patient profile can be viewed on insights page (INSI-01 completion).
</success_criteria>

<output>
After completion, create `.planning/phases/05-patient-insight-integration/05-03-SUMMARY.md`
</output>
