---
phase: 05-patient-insight-integration
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/app/api/patients/[id]/insights/route.ts
  - src/lib/data/repositories.ts
  - src/components/patients/InsightPanel.tsx
  - src/app/patients/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Insights persist across page reloads"
    - "Saved insights display immediately on patient profile"
    - "Therapist can regenerate to get updated analysis"
    - "GET endpoint returns saved insights"
    - "PATCH endpoint saves generated insights"
  artifacts:
    - path: "src/app/api/patients/[id]/insights/route.ts"
      provides: "GET and PATCH endpoints for insight persistence"
      exports: ["GET", "POST", "PATCH"]
    - path: "src/lib/data/repositories.ts"
      provides: "patientInsightsRepository with CRUD operations"
      contains: "patientInsightsRepository"
  key_links:
    - from: "src/components/patients/InsightPanel.tsx"
      to: "/api/patients/[id]/insights"
      via: "PATCH request in handleSave"
      pattern: "method.*PATCH"
    - from: "src/app/patients/[id]/page.tsx"
      to: "usePatientInsights hook or fetch"
      via: "load existing insights on mount"
      pattern: "insights.*patient"
---

<objective>
Add persistence layer for patient insights with GET/PATCH endpoints and saved state handling

Purpose: Enable insights to persist and be regenerated (INSI-08)
Output: Complete persistence flow with repository, API endpoints, and UI integration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-patient-insight-integration/05-01-SUMMARY.md
@.planning/phases/05-patient-insight-integration/05-02-SUMMARY.md
@src/app/api/patients/[id]/insights/route.ts
@src/lib/data/repositories.ts
@src/components/patients/InsightPanel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add insights repository</name>
  <files>src/lib/data/repositories.ts</files>
  <action>
Add patientInsightsRepository to the existing repositories file.

**Storage Pattern:**
Follow the same pattern as other repositories in the file (likely using JSON storage or mock data).

**Repository Interface:**
```typescript
export const patientInsightsRepository = {
  /**
   * Find insights by patient ID
   * Returns null if no saved insights exist
   */
  async findByPatientId(patientId: string): Promise<PatientInsights | null> {
    // Check if insights exist in storage for this patient
    // Return null if not found
  },

  /**
   * Save or update insights for a patient
   * If insights exist, update them; otherwise create new
   */
  async save(insights: PatientInsights): Promise<PatientInsights> {
    // Add savedAt and savedBy if not present
    // Store in data (following existing repository patterns)
    // Return the saved insights
  },

  /**
   * Delete insights for a patient (for regeneration)
   */
  async deleteByPatientId(patientId: string): Promise<void> {
    // Remove insights from storage
  },
};
```

**Import PatientInsights:**
Add to imports: `import type { PatientInsights } from '@/types';`

**Storage Location:**
If using JSON files, store in `data/insights/` directory.
If using in-memory mock, add to mock data structure.
Follow existing patterns in the file.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- patientInsightsRepository exported from repositories.ts
- findByPatientId, save, deleteByPatientId methods exist
  </verify>
  <done>
patientInsightsRepository exists with CRUD operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Add GET and PATCH endpoints</name>
  <files>src/app/api/patients/[id]/insights/route.ts</files>
  <action>
Add GET and PATCH handlers to the existing route file:

**GET /api/patients/[id]/insights**
Retrieves saved insights for a patient:
```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;

    // Validate patient exists
    const patient = await patientRepository.findById(id);
    if (!patient) {
      return NextResponse.json(
        { error: 'Patient not found' },
        { status: 404 }
      );
    }

    // Get saved insights
    const insights = await patientInsightsRepository.findByPatientId(id);

    // Return insights or null
    return NextResponse.json({ data: insights });
  } catch (error) {
    console.error('Error fetching patient insights:', error);
    return NextResponse.json(
      { error: 'Failed to fetch insights' },
      { status: 500 }
    );
  }
}
```

**PATCH /api/patients/[id]/insights**
Saves generated insights:
```typescript
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const body = await request.json();

    // Validate patient exists
    const patient = await patientRepository.findById(id);
    if (!patient) {
      return NextResponse.json(
        { error: 'Patient not found' },
        { status: 404 }
      );
    }

    // Validate required fields
    if (!body.insights) {
      return NextResponse.json(
        { error: 'Missing insights in request body' },
        { status: 400 }
      );
    }

    // Add persistence metadata
    const insightsToSave: PatientInsights = {
      ...body.insights,
      savedAt: new Date(),
      // savedBy would come from auth in real app
    };

    // Save insights
    const savedInsights = await patientInsightsRepository.save(insightsToSave);

    return NextResponse.json({ data: savedInsights });
  } catch (error) {
    console.error('Error saving patient insights:', error);
    return NextResponse.json(
      { error: 'Failed to save insights' },
      { status: 500 }
    );
  }
}
```

**Import:**
Add `patientInsightsRepository` to imports from '@/lib/data/repositories'
  </action>
  <verify>
- `npx tsc --noEmit` passes
- GET endpoint returns saved insights or null
- PATCH endpoint saves insights with savedAt timestamp
  </verify>
  <done>
GET and PATCH endpoints exist for insight persistence
  </done>
</task>

<task type="auto">
  <name>Task 3: Update InsightPanel for persistence</name>
  <files>src/components/patients/InsightPanel.tsx</files>
  <action>
Update InsightPanel to handle saved insights and persistence:

**1. Add handleSave function:**
```typescript
const handleSave = async () => {
  if (!insights) return;

  setSaveError(null);
  try {
    const response = await fetch(`/api/patients/${patientId}/insights`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ insights }),
    });

    const result = await response.json();

    if (!response.ok || result.error) {
      setSaveError(result.error || 'Failed to save insights');
      return;
    }

    // Update local state with saved version
    setInsights(result.data);
    setState('saved');
    onInsightsSaved?.();
  } catch {
    setSaveError('Failed to connect to server');
  }
};
```

**2. Handle existingInsights prop:**
```typescript
useEffect(() => {
  if (existingInsights) {
    setState(existingInsights.savedAt ? 'saved' : 'preview');
    setInsights(existingInsights);
  }
}, [existingInsights]);
```

**3. Update state type:**
Add `saveError` state for save-specific errors:
```typescript
const [saveError, setSaveError] = useState<string | null>(null);
```

**4. Saved state display:**
In saved state, show:
- "Saved" badge (green)
- savedAt timestamp formatted
- Regenerate button only (no Save button)
- Clear indication that insights are persisted

**5. Preview state display:**
- "Unsaved" badge (outline)
- Save button (primary)
- Regenerate button (secondary)
- saveError message if present
  </action>
  <verify>
- `npx tsc --noEmit` passes
- handleSave calls PATCH endpoint
- Saved state shows savedAt timestamp
- Save button works from preview state
  </verify>
  <done>
InsightPanel persists insights via PATCH and displays saved state
  </done>
</task>

<task type="auto">
  <name>Task 4: Load existing insights on patient page</name>
  <files>src/app/patients/[id]/page.tsx</files>
  <action>
Update patient page to load existing insights:

**1. Add state and fetch:**
```typescript
const [existingInsights, setExistingInsights] = useState<PatientInsights | null>(null);
const [insightsLoading, setInsightsLoading] = useState(false);

// Fetch existing insights on mount
useEffect(() => {
  const fetchInsights = async () => {
    if (!patient?.id) return;
    setInsightsLoading(true);
    try {
      const response = await fetch(`/api/patients/${patient.id}/insights`);
      const result = await response.json();
      if (result.data) {
        setExistingInsights(result.data);
      }
    } catch (error) {
      console.error('Failed to fetch insights:', error);
    } finally {
      setInsightsLoading(false);
    }
  };

  if (patient?.id && completedSessions.length > 0) {
    fetchInsights();
  }
}, [patient?.id, completedSessions.length]);
```

**2. Update InsightPanel props:**
```tsx
<InsightPanel
  patientId={patient.id}
  patientName={`${patient.firstName} ${patient.lastName}`}
  existingInsights={existingInsights}
  onInsightsSaved={() => {
    // Optionally refetch to get latest saved state
    // Or trust the InsightPanel's local state
  }}
/>
```

**3. Add import:**
```typescript
import type { PatientInsights } from '@/types';
```

**4. Handle loading:**
Show loading state in InsightPanel area while fetching, or let InsightPanel show empty and transition when insights arrive.
  </action>
  <verify>
- `npm run build` passes
- Page loads existing insights on mount
- InsightPanel shows saved state if insights exist
- New generation overwrites old saved insights
  </verify>
  <done>
Patient page loads and displays persisted insights
  </done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run build` succeeds
- [ ] GET /api/patients/[id]/insights returns saved insights
- [ ] PATCH /api/patients/[id]/insights saves insights
- [ ] InsightPanel Save button persists to API
- [ ] Patient page loads existing insights on mount
- [ ] Saved insights show "Saved" badge and savedAt timestamp
- [ ] Regenerate creates new insights (replaces old)
- [ ] Insights persist across page reloads
</verification>

<success_criteria>
Insights are saved and persist across sessions; therapist can regenerate to get updated analysis (INSI-08 satisfied)
</success_criteria>

<output>
After completion, create `.planning/phases/05-patient-insight-integration/05-03-SUMMARY.md`
</output>
